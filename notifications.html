<!DOCTYPE html>
<html>
    <head>
    </head>
    <body>

        <h1>River notifications</h1>

        <p>WARNING: River notifications are extremely expiramental. Please note that browser support is somewhat limited. </p>


        <p id="notificationPermission"></p>

        <p id="notificationsStatus"></p>
        <button id="subscribe">Enable Notifications</button>
        <button id="unsubscribe">Disable Notifications</button>

        <p>If notifications are enabled, here are the ones you will see:</p>
        <div id="currentSelections"></div>

        <!-- Consider adding a gauge name column. -->

        <style>
        .row {
            padding:8px;
            background-color: #999999;
        }
        .gaugeColumn {
            min-width:20%;
            width:20%;
            max-width:20%;
            display: inline-block;
        }
        .nameColumn {
            min-width:20%;
            width:20%;
            max-width:20%;
            display: inline-block;
        }
        .minColumn {
            min-width:20%;
            width:20%;
            max-width:20%;
            display: inline-block;
        }
        .maxColumn {
            min-width:20%;
            width:20%;
            max-width:20%;
            display: inline-block;
        }
        .deleteButton {
            min-width:20%;
            width:20%;
            max-width:20%;
            cursor:pointer;
        }
        @media (prefers-color-scheme: dark) {}
        </style>

        <script src="packages/allPages.js"></script>
        <script>


        let currentSelections = document.getElementById("currentSelections")
        //Add the header
        //This was HTML, but a space was added in between the spans, unless it was all in 1 line (and unreadable)
        currentSelections.innerHTML += '<div class="row"></div>'
        currentSelections.firstChild.innerHTML += '<span class="gaugeColumn">Gauge</span>'
        currentSelections.firstChild.innerHTML += '<span class="nameColumn">River Name</span>'
        currentSelections.firstChild.innerHTML += '<span class="minColumn">Minimum</span>'
        currentSelections.firstChild.innerHTML += '<span class="maxColumn">Maximum</span>'


        function redrawRows() {
            //Clear the current list.
            let rows = currentSelections.children
            //The first child element is the header. Start at position 1.
            for (let i=1;i<rows.length;i++) {
                rows[i].remove()
            }

            let selections = JSON.parse(localStorage.getItem("flownotifications") || "{}")

            for (let gauge in selections) {
                for (let name in selections[gauge]) {

                    let row = document.createElement("div")
                    row.className = "row"

                    let gaugeColumn = document.createElement("span")
                    gaugeColumn.className = "gaugeColumn"
                    gaugeColumn.innerHTML = gauge
                    row.appendChild(gaugeColumn)

                    let nameColumn = document.createElement("span")
                    nameColumn.className = "nameColumn"
                    nameColumn.innerHTML = name
                    row.appendChild(nameColumn)

                    let minColumn = document.createElement("span")
                    minColumn.className = "minColumn"
                    minColumn.innerHTML = selections[gauge][name].minimum
                    row.appendChild(minColumn)

                    let maxColumn = document.createElement("span")
                    maxColumn.className = "maxColumn"
                    maxColumn.innerHTML = selections[gauge][name].maximum
                    row.appendChild(maxColumn)

                    let deleteButton = document.createElement("span")
                    deleteButton.className = "deleteButton"
                    deleteButton.innerHTML = "âœ–"
                    row.appendChild(deleteButton)

                    deleteButton.addEventListener("click", function() {
                        if (confirm("Remove " + name + " at gauge " + gauge + "?")) {
                            delete selections[gauge][name]
                            //TODO: Consider trimming out empty objects.
                            localStorage.setItem("flownotifications", JSON.stringify(selections))
                        }
                    })

                    console.log(selections)
                    console.log(selections[gauge][name])

                    currentSelections.appendChild(row)
                }
            }
        }
        redrawRows()

        ;(async function() {

            window.sw = await navigator.serviceWorker.ready

            let notificationPermission = await navigator.permissions.query({name:"notifications"})
            function updatePermissionNotice() {
                if (notificationPermission.state === "denied") {
                    document.getElementById("notificationPermission").style.display = "block"
                    document.getElementById("notificationPermission").innerHTML = "You denied rivers.run notifications permission. You will need to change this in site settings."
                }
                else {
                    //If the permission state is either granted or prompt, don't bother the user.
                    document.getElementById("notificationPermission").style.display = "none"
                }
            }
            updatePermissionNotice()
            notificationPermission.onchange = updatePermissionNotice


            async function syncWithServer() {
                await fetch("https://rivers.run/node", {
                    method: "POST",
                    body:JSON.stringify({
                        subscription,
                        parameters: JSON.parse(localStorage.getItem("flownotifications") || "{}")
                    })
                })
            }


            async function updateSubscriptionStatus() {
                //TODO: Handle the scenario where the public key has changed. This will need code changes in other places too.
                if (await sw.pushManager.getSubscription() === null) {
                    document.getElementById("notificationsStatus").innerHTML = "All notifications are currently disabled."
                }
                else {
                    document.getElementById("notificationsStatus").innerHTML = "Notifications are currently enabled."
                }
            }
            updateSubscriptionStatus()



            document.getElementById("unsubscribe").addEventListener("click", async function() {
                if (await sw.pushManager.getSubscription() === null) {
                    alert("You are not subscribed to notifications")
                }
                else if (confirm("Are you sure that you no longer want to receive notifications when rivers become runnable?")) {
                    try {
                        let subscription = await sw.pushManager.getSubscription()
                        await subscription.unsubscribe()
                        alert("Unsubscribed from all river notifications")
                    }
                    catch (e) {
                        alert("Failed to unsubscribe from river notifications. Error message: \n\n" + e)
                    }
                    updateSubscriptionStatus()
                }
            })


            //Used to convert base64 vapidKey to Uint8Array.
            function urlBase64ToUint8Array(base64String) {
              const padding = '='.repeat((4 - base64String.length % 4) % 4);
              const base64 = (base64String + padding)
                .replace(/-/g, '+')
                .replace(/_/g, '/');

              const rawData = window.atob(base64);
              const outputArray = new Uint8Array(rawData.length);

              for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
              }
              return outputArray;
            }


            document.getElementById("subscribe").addEventListener("click", async function() {
                if (await sw.pushManager.getSubscription() !== null) {
                    alert("You are already subscribed to notifications")
                    return;
                }
                try {
                    await Notification.requestPermission()
                    //Load the public key.
                    let vapidKey = await fetch("public_key")
                    vapidKey = await vapidKey.text()
                    vapidKey = urlBase64ToUint8Array(vapidKey)
                    let subscription = await sw.pushManager.subscribe({
                        userVisibleOnly: true, //Chrome requires this to be set to true.
                        applicationServerKey: vapidKey
                    })
                }
                catch (e) {
                    alert("Failed to subscribe to river notifications. Error message: \n\n" + e)
                }
                updateSubscriptionStatus()
            })



        }());
        </script>
    </body>
</html>
