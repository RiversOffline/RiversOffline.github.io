<!DOCTYPE html>
<html>
    <head>
    </head>
    <body>

        <h1>River notifications</h1>



        <p id="notificationPermission"></p>

        <p id="notificationsStatus"></p>
        <button id="subscribe">Enable Notifications</button>
        <button id="unsubscribe">Disable Notifications</button>

        <p>If notifications are enabled, here are the ones you will see:</p>
        <div id="currentSelections"></div>

        <!-- Consider adding a gauge name column. -->

        <style>
        .row {
            padding:8px;
            background-color: #bbbbbb;
        }
        .row:nth-child(odd) {
            background-color: #cccccc;
        }
        .row:first-child {
            background-color:lightgreen;
        }

        #subscribe, #unsubscribe {
            font-size: 16px;
        }

        .gaugeColumn {
            min-width:20%;
            width:20%;
            max-width:20%;
            display: inline-block;
        }
        .nameColumn {
            min-width:20%;
            width:20%;
            max-width:20%;
            display: inline-block;
        }
        .minColumn {
            min-width:20%;
            width:20%;
            max-width:20%;
            display: inline-block;
        }
        .maxColumn {
            min-width:20%;
            width:20%;
            max-width:20%;
            display: inline-block;
        }
        .deleteButton {
            min-width:20%;
            width:20%;
            max-width:20%;
            cursor:pointer;
        }

        @media (prefers-color-scheme: dark) {
            html, body {
                background-color: black;
                color: white;
            }
            .row {
                background-color: #555555;
            }
            .row:nth-child(odd) {
                background-color: #666666;
            }
            .row:first-child {
                background-color:darkgreen;
            }
        }

        </style>

        <script src="packages/allPages.js"></script>
        <script>
        //TODO: Add a way for users to sync between devices.

        let currentSelections = document.getElementById("currentSelections")
        //Add the header
        //This was HTML, but a space was added in between the spans, unless it was all in 1 line (and unreadable)
        currentSelections.innerHTML += '<div class="row"></div>'
        currentSelections.firstChild.innerHTML += '<span class="gaugeColumn">Gauge</span>'
        currentSelections.firstChild.innerHTML += '<span class="nameColumn">River Name</span>'
        currentSelections.firstChild.innerHTML += '<span class="minColumn">Minimum</span>'
        currentSelections.firstChild.innerHTML += '<span class="maxColumn">Maximum</span>'
        currentSelections.firstChild.innerHTML += '<span class="deleteButton">Delete</span>'


        function redrawRows() {
            //Clear the current list.
            let rows = currentSelections.children
            //The first child element is the header. Don't delete the firstChild, but the nextSibling.
            while (currentSelections.firstChild.nextSibling) {
                currentSelections.firstChild.nextSibling.remove()
            }

            let selections = JSON.parse(localStorage.getItem("flownotifications") || "{}")

            for (let gauge in selections) {
                for (let name in selections[gauge]) {

                    let row = document.createElement("div")
                    row.className = "row"

                    let gaugeColumn = document.createElement("span")
                    gaugeColumn.className = "gaugeColumn"
                    gaugeColumn.innerHTML = gauge
                    row.appendChild(gaugeColumn)

                    let nameColumn = document.createElement("span")
                    nameColumn.className = "nameColumn"
                    nameColumn.innerHTML = name
                    row.appendChild(nameColumn)

                    let minColumn = document.createElement("span")
                    minColumn.className = "minColumn"
                    minColumn.innerHTML = selections[gauge][name].minimum + selections[gauge][name].units
                    row.appendChild(minColumn)

                    let maxColumn = document.createElement("span")
                    maxColumn.className = "maxColumn"
                    maxColumn.innerHTML = selections[gauge][name].maximum + selections[gauge][name].units
                    row.appendChild(maxColumn)

                    let deleteButton = document.createElement("span")
                    deleteButton.className = "deleteButton"
                    deleteButton.innerHTML = "âœ–"
                    row.appendChild(deleteButton)

                    deleteButton.addEventListener("click", function() {
                        if (confirm("Remove " + name + " at gauge " + gauge + "?")) {
                            delete selections[gauge][name]
                            //Trim out the gauge object if it is empty.
                            if (Object.keys(selections[gauge]).length === 0) {
                                delete selections[gauge]
                            }
                            localStorage.setItem("flownotifications", JSON.stringify(selections))
                            redrawRows()
                        }
                    })

                    currentSelections.appendChild(row)
                }
            }
        }
        redrawRows()

        ;(async function() {

            window.sw = await navigator.serviceWorker.ready

            let notificationPermission = await navigator.permissions.query({name:"notifications"})
            function updatePermissionNotice() {
                if (!"PushManager" in window || !"Notification" in window) {
                    document.getElementById("notificationPermission").style.display = "block"
                    document.getElementById("notificationPermission").innerHTML = "Your browser does not support flow notifications."
                }
                else if (notificationPermission.state === "denied") {
                    document.getElementById("notificationPermission").style.display = "block"
                    document.getElementById("notificationPermission").innerHTML = "You denied rivers.run notifications permission. You will need to change this in site settings."
                }
                else {
                    //If the permission state is either granted or prompt, don't bother the user.
                    document.getElementById("notificationPermission").style.display = "none"
                }
            }
            updatePermissionNotice()
            notificationPermission.onchange = updatePermissionNotice


            async function syncWithServer() {
                await fetch("https://rivers.run/node", {
                    method: "POST",
                    body:JSON.stringify({
                        subscription: await sw.pushManager.getSubscription(),
                        parameters: JSON.parse(localStorage.getItem("flownotifications") || "{}")
                    })
                })
            }

            //URL is the unique url push notifications are received from.
            //This can be used to recover lost data if localStorage is cleared, or to sync between devices.
            async function getSubscriptionFromURL(url) {
                await fetch("https://rivers.run/node", {
                    method: "POST",
                    body:JSON.stringify({
                        getSubscriptionFromURL: url
                    })
                })
            }

            async function updateSubscriptionStatus() {
                //TODO: Handle the scenario where the public key has changed. This will need code changes in other places too.
                if (await sw.pushManager.getSubscription() === null) {
                    document.getElementById("notificationsStatus").innerHTML = "All notifications are currently disabled."
                }
                else {
                    document.getElementById("notificationsStatus").innerHTML = "Notifications are currently enabled."
                }
            }
            updateSubscriptionStatus()



            document.getElementById("unsubscribe").addEventListener("click", async function() {
                if (await sw.pushManager.getSubscription() === null) {
                    alert("You are not subscribed to notifications")
                }
                else if (confirm("Are you sure that you no longer want to receive notifications when rivers become runnable?")) {
                    try {
                        let subscription = await sw.pushManager.getSubscription()
                        await subscription.unsubscribe()
                        alert("Unsubscribed from all river notifications")
                    }
                    catch (e) {
                        alert("Failed to unsubscribe from river notifications. Error message: \n\n" + e)
                    }
                    updateSubscriptionStatus()
                }
            })


            //Used to convert base64 vapidKey to Uint8Array.
            function urlBase64ToUint8Array(base64String) {
              const padding = '='.repeat((4 - base64String.length % 4) % 4);
              const base64 = (base64String + padding)
                .replace(/-/g, '+')
                .replace(/_/g, '/');

              const rawData = window.atob(base64);
              const outputArray = new Uint8Array(rawData.length);

              for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
              }
              return outputArray;
            }


            document.getElementById("subscribe").addEventListener("click", async function() {
                if (await sw.pushManager.getSubscription() !== null) {
                    alert("You are already subscribed to notifications")
                    return;
                }
                try {
                    await Notification.requestPermission()
                    //Load the public key.
                    let vapidKey = await fetch("public_key")
                    vapidKey = await vapidKey.text()
                    vapidKey = urlBase64ToUint8Array(vapidKey)
                    let subscription = await sw.pushManager.subscribe({
                        userVisibleOnly: true, //Chrome requires this to be set to true.
                        applicationServerKey: vapidKey
                    })
                }
                catch (e) {
                    alert("Failed to subscribe to river notifications. Error message: \n\n" + e)
                }
                updateSubscriptionStatus()
            })



        }());
        </script>
    </body>
</html>
